---
title: परियोजना शेड्यूल API प्रदर्शन
description: यह विषय परियोजना शेड्यूल API के प्रदर्शन बेंचमार्क के बारे में जानकारी देता है और श्रेष्ठ उपयोग के लिए सर्वोत्तम कार्यप्रणालियों की पहचान करता है.
author: ruhercul
ms.date: 11/03/2021
ms.topic: article
ms.reviewer: johnmichalak
ms.author: sigitac
ms.openlocfilehash: 3c14d27c561a86cd359cbdcbb448ae764dd3d90e
ms.sourcegitcommit: c0792bd65d92db25e0e8864879a19c4b93efb10c
ms.translationtype: MT
ms.contentlocale: hi-IN
ms.lasthandoff: 04/14/2022
ms.locfileid: "8593844"
---
# <a name="project-schedule-api-performance"></a>परियोजना शेड्यूल API प्रदर्शन

_**इस पर लागू होता है:** संसाधन/गैर-स्टॉक आधारित परिदृश्यों के लिए Project Operations, लाइट परिनियोजन - प्रोफार्मा चालान-प्रक्रिया के लिए सौदा, Project for the web_

यह विषय परियोजना शेड्यूल अनुप्रयोग प्रोग्रामिंग इंटरफेस (API) के प्रदर्शन बेंचमार्क के बारे में जानकारी देता है और उपयोग को अनुकूलित करने के लिए सर्वोत्तम कार्यप्रणालियों की पहचान करता है.

## <a name="project-scheduling-service"></a>परियोजना शेड्यूलिंग सेवा
परियोजना शेड्यूलिंग सेवा Microsoft Azure में चलने वाली मल्टी-टैनेंट सेवा है. उपयोगकर्ता द्वारा परियोजना पर काम करने के दौरान इसे तेज़ और आसान अनुभव प्रदान करके बातचीत को बेहतर बनाने के लिए डिज़ाइन किया गया है. यह सुधार परिवर्तन अनुरोधों को स्वीकार करने, उन्हें संसाधित करने और फिर तुरंत परिणाम वापस करने से प्राप्त होता है. सेवा असमकालिक रूप से Dataverse के लिए बनी रहती है और उपयोगकर्ताओं को अन्य संचालन करने से नहीं रोकती है.

इस विषय के बाद के अनुभागों में अधिक विवरण में वर्णित अनुरोधों को चलाने के लिए परियोजना शेड्यूल API परियोजना शेड्यूलिंग सेवा पर निर्भर होते हैं.

परियोजना शेड्यूल API को निम्न कार्य विश्लेषण संरचना (WBS) निकायों के साथ कार्य करने के लिए डिज़ाइन किया गया है:

  - Project
  - परियोजना कार्य
  - परियोजना कार्य निर्भरता
  - परियोजना टीम सदस्य
  - संसाधन असाइनमेंट
  
आउट-ऑफ़-बॉक्स फ़ील्ड और कस्टम फ़ील्ड दोनों समर्थित हैं. जब तक अलग से जिक्र न किया गया हो, सभी सामान्य संचालन समर्थित हैं, जैसे बनाना, अपडेट करना और हटाना. अधिक जानकारी के लिए, [कार्य और शेड्यूलिंग निकाय निष्पादित करने के लिए परियोजना शेड्यूल API का उपयोग करें](schedule-api-preview.md) देखें.

परियोजना शेड्यूल API के हिस्से के रूप में, एक यूनिट-ऑफ-वर्क पैटर्न जोड़ा गया है. इस पैटर्न को OperationSet के रूप में जाना जाता है और इसका उपयोग तब किया जा सकता है जब एक ही लेनदेन में कई अनुरोधों को संसाधित किया जाना हो.

निम्न उदाहरण उस प्रवाह को दिखाता है, जिसे इस फ़ीचर का उपयोग करने पर कोई भागीदार अनुभव करेगा.

![Dataverse और परियोजना शेड्यूलिंग सेवा प्रवाह.](./media/dataverse-project-scheduling-service-flow.png)

**चरण 1**: OperationSet बनाने के लिए क्लाइंट Dataverse में ओपन डेटा प्रोटोकॉल (OData) समाप्ति बिंदु पर API कॉल करता है.

**चरण 2**: नया OperationSet बनने के बाद, **OperationSetId** मान लौटाया जाता है.

**चरण 3**: क्लाइंट अन्य परियोजना शेड्यूल API अनुरोध करने के लिए **OperationSetId** मान का उपयोग करता है. परिणाम एक शेड्यूलिंग निकाय पर बनाने, अपडेट करने या हटाने का अनुरोध होता है. जब यह अनुरोध किया जाता है, तो मेटाडेटा सत्यापन किया जाता है. यदि सत्यापन विफल हो जाता है, तो अनुरोध समाप्त हो जाता है और एक त्रुटि मिलती है.

**चरण 4a–4c**: ये चरण ACCEPT चरण का प्रतिनिधित्व करते हैं. क्लाइंट **ExecuteOperationSetV1** API को कॉल करता है, जो परियोजना शेड्यूलिंग सेवा में सभी परिवर्तन एक बैच में भेजता है. परियोजना शेड्यूलिंग सेवा अनुरोधों पर बैच में अपना सत्यापन चलाती है. कोई भी सत्यापन विफलता बैच को पूर्ववत करता है और कॉलर को अपवाद लौटाता है. यदि बैच को परियोजना शेड्यूलिंग सेवा द्वारा सफलतापूर्वक स्वीकार कर लिया जाता है, तो इस तथ्य को दर्शाने के लिए OperationSet स्थिति को अपडेट किया जाता है कि OperationSet को परियोजना शेड्यूलिंग सेवा द्वारा संसाधित किया जा रहा है.

**चरण 5**: यह चरण PERSIST चरण का प्रतिनिधित्व करता है. परियोजना शेड्यूलिंग सेवा एसिंक्रोनस रूप से एक लेन-देन में Dataverse को बैच लिखती है. यदि लेखन कार्य सफल होता है, तो OperationSet को **पूर्ण** के रूप में चिह्नित किया जाता है. कोई भी त्रुटि लेन-देन और बैच को वापस ले लेती है और OperationSet को **विफल** के रूप में चिह्नित किया जाता है.

## <a name="performance-methodology"></a>प्रदर्शन क्रियाविधि
जब तक कि परियोजना शेड्यूलिंग सेवा Dataverse को लिखना समाप्त नहीं कर देती निष्पादन समय को कॉल से **ExecuteOperationSetV1** API तक के समय के रूप में परिभाषित किया जाता है. सभी कार्य मिलकर 2,200 बार चलते हैं और P99 निष्पादन समय मापन को रिपोर्ट किया जाता है. सिंगल-रिकॉर्ड और बल्क कार्यों को मापा जाता है.

सिंगल-रिकॉर्ड कार्य के लिए, OperationSet में एक अनुरोध होता है. बल्क कार्यों के लिए, इसमें 20, 50 या 100 अनुरोध होते हैं. प्रत्येक बल्क आकार को अलग से सूचित किया जाता है.

ये कार्य उत्तरी अमेरिका में UR 15 Project Operations लाइट परिनियोजन पर चलते हैं.

## <a name="results"></a>परिणाम
### <a name="create-operations"></a>कार्रवाई बनाएँ
#### <a name="single-record-create-operations"></a>एकल-रिकॉर्ड बनाने के संचालन
नीचे दी गई तालिका एकल रिकॉर्ड बनाने के लिए निष्पादन समय दिखाती है. समय सेकंड में हैं.

<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax" rowspan="2">रिकॉर्ड&nbsp;&nbsp;&nbsp;प्रकार</th>
    <th class="tg-0lax" colspan="2">समय</th>
  </tr>
  <tr>
    <th class="tg-0lax">आवश्यक फ़ील्ड्स</th>
    <th class="tg-0lax">सभी समर्थित फ़ील्ड्स</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">Project</td>
    <td class="tg-0lax">2.5</td>
    <td class="tg-0lax">3.78</td>
  </tr>
  <tr>
    <td class="tg-0lax">कार्य</td>
    <td class="tg-0lax">8.82</td>
    <td class="tg-0lax">9.34</td>
  </tr>
  <tr>
    <td class="tg-0lax">असाइनमेंट</td>
    <td class="tg-0lax">9.19</td>
    <td class="tg-0lax">9.19</td>
  </tr>
  <tr>
    <td class="tg-0lax">टीम सदस्य</td>
    <td class="tg-0lax">0.84</td>
    <td class="tg-0lax">4.2</td>
  </tr>
  <tr>
    <td class="tg-0lax">निर्भरता</td>
    <td class="tg-0lax">8.84</td>
    <td class="tg-0lax">8.84</td>
  </tr>
</tbody>
</table>

#### <a name="bulk-create-operations"></a>सामूहिक कार्रवाई बनाएँ
निम्न तालिका कई रिकॉर्ड बनाने के लिए निष्पादन समय दिखाती है. विशेष रूप से, Microsoft ने एकल OperationSet में 20, 50 और 100 रिकॉर्ड बनाने के लिए निष्पादन समय को मापा. समय सेकंड में हैं.

<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax" rowspan="3">रिकॉर्ड&nbsp;&nbsp;&nbsp;प्रकार</th>
    <th class="tg-0lax" colspan="6">समय</th>
  </tr>
  <tr>
    <th class="tg-0lax" colspan="2">20 रिकॉर्ड</th>
    <th class="tg-0lax" colspan="2">50 रिकॉर्ड</th>
    <th class="tg-0lax" colspan="2">100 रिकॉर्ड</th>
  </tr>
  <tr>
    <th class="tg-0lax">आवश्यक फ़ील्ड्स</th>
    <th class="tg-0lax">सभी समर्थित फ़ील्ड्स</th>
    <th class="tg-0lax">आवश्यक फ़ील्ड्स</th>
    <th class="tg-0lax">सभी समर्थित फ़ील्ड्स</th>
    <th class="tg-0lax">आवश्यक फ़ील्ड्स</th>
    <th class="tg-0lax">सभी समर्थित फ़ील्ड्स</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">कार्य</td>
    <td class="tg-0lax">19.92</td>
    <td class="tg-0lax">38.35</td>
    <td class="tg-0lax">36.67</td>
    <td class="tg-0lax">99.13</td>
    <td class="tg-0lax">116.77</td>
    <td class="tg-0lax">174.06</td>
  </tr>
  <tr>
    <td class="tg-0lax">असाइनमेंट</td>
    <td class="tg-0lax">13.94</td>
    <td class="tg-0lax">13.94</td>
    <td class="tg-0lax">43.95</td>
    <td class="tg-0lax">43.95</td>
    <td class="tg-0lax">69.38</td>
    <td class="tg-0lax">69.38</td>
  </tr>
  <tr>
    <td class="tg-0lax">निर्भरता</td>
    <td class="tg-0lax">30.04</td>
    <td class="tg-0lax">30.04</td>
    <td class="tg-0lax">77.82</td>
    <td class="tg-0lax">77.82</td>
    <td class="tg-0lax">176.89</td>
    <td class="tg-0lax">176.89</td>
  </tr>
</tbody>
</table>

> [!NOTE] 
> इस तालिका में **परियोजना** और **टीम सदस्य** निकायों पर बल्क क्रिएट ऑपरेशन शामिल नहीं हैं, क्योंकि उन संचालनों के लिए रनटाइम उस रनटाइम जैसा दिखता है जब एक रिकॉर्ड बनाने के लिए API को कई बार कॉल किया जाता है. ये API तुरंत Dataverse में चलाए जाते हैं.

जब 20, 50 और 100 रिकॉर्ड बनाए जाते हैं और सभी समर्थित फ़ील्ड का उपयोग किया जाता है तो निम्न उदाहरण **कार्य**, **असाइनमेंट** और **निर्भरता** निकायों के लिए निष्पादन समय का प्लॉट दिखाता है.

![रिकॉर्ड निष्पादन समय ग्राफ बनाएं.](./media/create-record-execution-time.png)

### <a name="update-operations"></a>कार्रवाई अपडेट करें
#### <a name="single-record-update-operations"></a>एकल-रिकॉर्ड अपडेट ऑपरेशन
निम्न तालिका एकल रिकॉर्ड को अपडेट करने के लिए निष्पादन समय दिखाती है. समय सेकंड में हैं.

<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax" rowspan="2">रिकॉर्ड&nbsp;&nbsp;&nbsp;प्रकार</th>
    <th class="tg-0lax" colspan="2">समय</th>
  </tr>
  <tr>
    <th class="tg-0lax">आवश्यक फ़ील्ड्स </th>
    <th class="tg-0lax">सभी समर्थित फ़ील्ड्स</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">Project</td>
    <td class="tg-0lax">9.53</td>
    <td class="tg-0lax">13.91</td>
  </tr>
  <tr>
    <td class="tg-0lax">कार्य</td>
    <td class="tg-0lax">8.82</td>
    <td class="tg-0lax">9.91</td>
  </tr>
  <tr>
    <td class="tg-0lax">टीम सदस्य</td>
    <td class="tg-0lax">9</td>
    <td class="tg-0lax">8.96</td>
  </tr>
</tbody>
</table>

> [!NOTE]
> **संसाधन असाइनमेंट** और **परियोजना कार्य निर्भरता** निकायों पर अपडेट संचालन समर्थित नहीं हैं.

#### <a name="bulk-update-operations"></a>सामूहिक कार्रवाई अद्यतित करें
निम्न तालिका कई रिकॉर्ड को अपडेट करने के लिए निष्पादन समय दिखाती है. विशेष रूप से, Microsoft ने एक ही OperationSet में 20, 50 और 100 रिकॉर्ड को अपडेट करने के लिए निष्पादन समय को मापा. समय सेकंड में हैं.

<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax" rowspan="3">रिकॉर्ड&nbsp;&nbsp;&nbsp;प्रकार</th>
    <th class="tg-0lax" colspan="6">समय</th>
  </tr>
  <tr>
    <th class="tg-0lax" colspan="2">20 रिकॉर्ड</th>
    <th class="tg-0lax" colspan="2">50 रिकॉर्ड</th>
    <th class="tg-0lax" colspan="2">100 रिकॉर्ड</th>
  </tr>
  <tr>
    <th class="tg-0lax">आवश्यक फ़ील्ड्स</th>
    <th class="tg-0lax">सभी समर्थित फ़ील्ड्स</th>
    <th class="tg-0lax">आवश्यक फ़ील्ड्स</th>
    <th class="tg-0lax">सभी समर्थित फ़ील्ड्स</th>
    <th class="tg-0lax">आवश्यक फ़ील्ड्स</th>
    <th class="tg-0lax">सभी समर्थित फ़ील्ड्स</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">कार्य</td>
    <td class="tg-0lax">8.91</td>
    <td class="tg-0lax">38.71</td>
    <td class="tg-0lax">20.92</td>
    <td class="tg-0lax">87.13</td>
    <td class="tg-0lax">36.68</td>
    <td class="tg-0lax">190.34</td>
  </tr>
  <tr>
    <td class="tg-0lax">टीम सदस्य</td>
    <td class="tg-0lax">20.52</td>
    <td class="tg-0lax">26.06</td>
    <td class="tg-0lax">41.93</td>
    <td class="tg-0lax">44.51</td>
    <td class="tg-0lax">38.63</td>
    <td class="tg-0lax">66.53</td>
  </tr>
</tbody>
</table>

> [!NOTE]
> **संसाधन असाइनमेंट** और **परियोजना कार्य निर्भरता** निकायों पर अपडेट संचालन समर्थित नहीं हैं.

जब 20, 50, और 100 रिकॉर्ड अपडेट किए जाते हैं और सभी समर्थित फ़ील्ड का उपयोग किया जाता है, तो निम्न उदाहरण कार्य और टीम सदस्य निकायों के लिए निष्पादन समय का प्लॉट दिखाता है.

![रिकॉर्ड निष्पादन समय ग्राफ अपडेट करें.](./media/update-record-execution-time.png)

### <a name="delete-operations"></a>कार्रवाई हटाएँ
#### <a name="single-record-delete-operations"></a>एकल-रिकॉर्ड हटाएं संचालन
निम्न तालिका एकल रिकॉर्ड को हटाने का निष्पादन समय दिखाती है. समय सेकंड में हैं.

| रिकॉर्ड प्रकार | समय  |
|-------------|-------|
| कार्य        | 20.12 |
| असाइनमेंट  | 10.86 |
| टीम सदस्य | 12.52 |
| निर्भरता  | 20.89 |

> [!NOTE]
> **परियोजना** निकाय पर हटाने की कार्रवाई समर्थित नहीं है.

#### <a name="bulk-delete-operations"></a>सामूहिक हटाएँ कार्रवाई
निम्न तालिका कई रिकॉर्ड को हटाने के लिए निष्पादन समय दिखाती है. विशेष रूप से, Microsoft ने एकल OperationSet में 20, 50 और 100 रिकॉर्ड को हटाने के लिए निष्पादन समय को मापा. समय सेकंड में हैं.

<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax" rowspan="2">रिकॉर्ड&nbsp;&nbsp;&nbsp;प्रकार</th>
    <th class="tg-0lax" colspan="3">समय</th>
  </tr>
  <tr>
    <th class="tg-0lax">20 रिकॉर्ड</th>
    <th class="tg-0lax">50 रिकॉर्ड</th>
    <th class="tg-0lax">100 रिकॉर्ड</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">कार्य</td>
    <td class="tg-0lax">20.91</td>
    <td class="tg-0lax">67.43</td>
    <td class="tg-0lax">71.96</td>
  </tr>
  <tr>
    <td class="tg-0lax">असाइनमेंट</td>
    <td class="tg-0lax">11.75</td>
    <td class="tg-0lax">25.79</td>
    <td class="tg-0lax">47.66</td>
  </tr>
  <tr>
    <td class="tg-0lax">टीम सदस्य</td>
    <td class="tg-0lax">9.78</td>
    <td class="tg-0lax">39.73</td>
    <td class="tg-0lax">24.33</td>
  </tr>
  <tr>
    <td class="tg-0lax">निर्भरता</td>
    <td class="tg-0lax">24.61</td>
    <td class="tg-0lax">54.9</td>
    <td class="tg-0lax">109.16</td>
  </tr>
</tbody>
</table>

> [!NOTE]
> **परियोजना** निकाय पर हटाने की कार्रवाई समर्थित नहीं है.

जब 20, 50 और 100 रिकॉर्ड हटा दिए जाते हैं, तो निम्न उदाहरण **कार्य**, **असाइनमेंट**, **टीम सदस्य** और **निर्भरता** निकायों के निष्पादन समय का प्लॉट दिखाता है.

![रिकॉर्ड निष्पादन समय ग्राफ हटाएं.](./media/delete-record-execution-time.png)

## <a name="observations"></a>अवलोकन
प्रत्येक रिकॉर्ड ऑपरेशन के लिए, **ExecuteOperationSet** API को परियोजना शेड्यूलिंग सेवा को अनुरोध भेजने में लगभग 800 मिलीसेकंड का समय लगता है. तब परियोजना शेड्यूलिंग सेवा पेलोड को संसाधित करने और Dataverse को कॉल करने में लगभग पांच सेकंड का समय लेती है. निष्पादन का शेष समय Dataverse में डेटाबेस में व्यावसायिक तर्क चलाने और डेटा लिखने में लगता है.

जब 100 रिकॉर्ड बनाए जाते हैं, अपडेट किए जाते हैं या हटा दिए जाते हैं, तो **ExecuteOperationSet** API को परियोजना शेड्यूलिंग सेवा को अनुरोध भेजने में लगभग तीन सेकंड का समय लगता है. तब परियोजना शेड्यूलिंग सेवा अनुरोधों को संसाधित करने और Dataverse को कॉल करने में लगभग पांच सेकंड का समय लेती है. OperationSet में सभी रिकॉर्ड के लिए बल्क संचालन को एक बार **परियोजना शेड्यूलिंग सेवा कर** का भुगतान करना होगा. इसलिए, एकल-रिकॉर्ड संचालन की तुलना में बल्क संचालन में औसत निष्पादन समय काफी कम होता है.

## <a name="scenarios"></a>परिदृश्य
जब परियोजना शेड्यूल API का उपयोग विशिष्ट परिदृश्यों को पूरा करने के लिए किया जाता है तो निम्न तालिका निष्पादन समय दिखाती है. समय सेकंड में हैं.

| परिदृश्य                                                                   | समय  |
|----------------------------------------------------------------------------|-------|
| परियोजना बनाएं, जिसमें 40 कार्य हों.                                      | 36.01 |
| परियोजना बनाएं, जिसमें 40 कार्य और 20 निर्भरताएं हों.                  | 38.11 |
| एक परियोजना बनाएं जिसमें 40 कार्य और 30 असाइनमेंट हों.                   | 60.17 |
| एक परियोजना बनाएं जिसमें 40 कार्य, 20 निर्भरताएं और 30 असाइनमेंट हों. | 60.27 |

## <a name="best-practices"></a>सर्वश्रेष्ठ व्यवहार
पिछले परिदृश्य परिणामों के आधार पर, API निम्नलिखित स्थितियों में बेहतर प्रदर्शन करते हैं:

  - जितना संभव हो उतने कार्यों को एक साथ समूह करें. बल्क संचालनों के लिए औसत रनटाइम एकल-रिकॉर्ड संचालनों के लिए औसत रनटाइम से बेहतर है. उपयोग में आने वाले OperationSets की संख्या जितनी कम होगी, औसत निष्पादन समय उतना ही तेज़ होगा.
  - सिर्फ वे न्यूनतम एट्रीब्यूट सेट करें, जो आपके परिदृश्य को पूरा करने के लिए आवश्यक हैं. OperationSet अनुरोध में शामिल गैर-आवश्यक फ़ील्ड प्रकारों के बारे में चयनात्मक रहें. बाहरी कुंजी या रोलअप फ़ील्ड वाले फ़ील्ड प्रदर्शन को नकारात्मक रूप से प्रभावित करेंगे.
